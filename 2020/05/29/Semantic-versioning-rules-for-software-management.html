<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <!-- Render GitHub Markdown style https://github.com/sindresorhus/github-markdown-css -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.css">
    <style>
    	.markdown-body {
    		box-sizing: border-box;
    		min-width: 200px;
    		max-width: 980px;
    		margin: 0 auto;
    		padding: 45px;
    	}

    	@media (max-width: 767px) {
    		.markdown-body {
    			padding: 15px;
    		}
    	}
    </style>

    <!-- GitHub markdown style configuration ends here -->

    <title>Semantic versioning rules for software management</title>
    <meta name="author" content="fubar">
    <meta name="description" content="A collection of HOWTOs in programming and commonly used tools by graduate students with focus on physicists. Additionally, an attempt is made to understand the intricate connection between Adwaitha / అద్వైతా / अद्वैता philosophy, physics and Mother Nature.">
    <link rel="icon" href="/assets/images/favicon.png" type="image/x-icon">

    <!-- custom style sheet -->
    <!-- uncomment to import the css file
        <link rel="stylesheet" href="/assets/css/styles.css">
     -->
    <script src="/js/snap.svg-min.js" defer></script>
    <link type="application/atom+xml" rel="alternate" href="/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Semantic versioning rules for software management</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Semantic versioning rules for software management" />
<meta name="author" content="fubar" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="We will describe the rules for versioning software to avoid dependency hell" />
<meta property="og:description" content="We will describe the rules for versioning software to avoid dependency hell" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-29T00:00:00+05:30" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/2020/05/29/Semantic-versioning-rules-for-software-management.html","headline":"Semantic versioning rules for software management","dateModified":"2020-05-29T00:00:00+05:30","datePublished":"2020-05-29T00:00:00+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"/2020/05/29/Semantic-versioning-rules-for-software-management.html"},"author":{"@type":"Person","name":"fubar"},"description":"We will describe the rules for versioning software to avoid dependency hell","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body class="markdown-body">
    <img class="fit-picture"
     src="/assets/images/swamiVivekananda.svg"
     alt="Swami Vivekananda">

<nav class=navigation>
  
  <!-- uncomment below line to render the names of the navigation items -->
<!--
    <a href="/" >Home</a>
-->
    <a
        href="/" >
            <img src="/assets/images/homePageHomeLogo.svg" alt="homepage logo">
    </a>
  
  <!-- uncomment below line to render the names of the navigation items -->
<!--
    <a href="/about.html" >About</a>
-->
    <a
        href="/about.html" >
            <img src="/assets/images/homePageAboutLogo.svg" alt="about logo">
    </a>
  
  <!-- uncomment below line to render the names of the navigation items -->
<!--
    <a href="/blog.html" >Blog</a>
-->
    <a
        href="/blog.html" >
            <img src="/assets/images/homePagePostsLogo.svg" alt="blog logo">
    </a>
  
  <!-- uncomment below line to render the names of the navigation items -->
<!--
    <a href="/staff.html" >Staff</a>
-->
    <a
        href="/staff.html" >
            <img src="/assets/images/homePageStaffLogo.svg" alt="staff logo">
    </a>
  

</nav>

<nav class=navigation-tags>
    <p>Post Tags</p>
    
        <a href="/physics.html"
           
        >
           physics
        </a>
    
        <a href="/programming.html"
           
        >
           programming
        </a>
    
        <a href="/yoga.html"
           
        >
           yoga
        </a>
    
        <a href="/education.html"
           
        >
           education
        </a>
    
        <a href="/nature.html"
           
        >
           nature
        </a>
    
 </nav>

    <h1 class="Headnote">Semantic versioning rules for software management</h1>
<p >
  29 May 2020 - fubar
  
  
    - <a href="/authors/fubar.html">Sreekar Guddeti</a>
  
</p>

<div class="box">
<img src="/assets/images/Git/gitLogo.svg" alt="Git-logo" width="150px" />
</div>

<h2 id="abstract">Abstract</h2>

<p><a href="https://semver.org/">Semantic versioning</a> rules to update a software at a version <code class="highlighter-rouge">MAJOR.MINOR.PATCH</code> recommend</p>
<ul>
  <li>incrementing <code class="highlighter-rouge">MAJOR</code> version when you make incompatible API changes</li>
  <li>incrementing <code class="highlighter-rouge">MINOR</code> version when you add functionality in a backwards compatible manner</li>
  <li>incrementing <code class="highlighter-rouge">PATCH</code> version when you make backwards compatible bug fixes.</li>
</ul>

<p>Software development is a multi user multi platform multi-organization endeavour. Each piece of program depends on other libraries.
Just as a program goes through iterative process of development, the dependencies undergo their own cycles of development. Lets say we develop a <code class="highlighter-rouge">program P</code> that provides a <code class="highlighter-rouge">plugin p1</code>. Let this be the current <code class="highlighter-rouge">version x</code> of <code class="highlighter-rouge">program P</code> and denote it by <code class="highlighter-rouge">P(x)</code>. <code class="highlighter-rouge">P(x)</code> depends on the current <code class="highlighter-rouge">version y</code> of <code class="highlighter-rouge">library L</code>. Let us denoted this version of <code class="highlighter-rouge">library L</code> by <code class="highlighter-rouge">L(y)</code>. <code class="highlighter-rouge">L(x)</code> has certain <strong>functionalities</strong> like <code class="highlighter-rouge">f1</code> and <code class="highlighter-rouge">f2</code>, of which <code class="highlighter-rouge">p1</code> needs <code class="highlighter-rouge">f1</code>. So we build on top of the API of the <code class="highlighter-rouge">L(x)</code> by using only <code class="highlighter-rouge">f1</code> in our program <code class="highlighter-rouge">P</code>.</p>

<p>So far so good. However in the course of time, we progress with our development and add an extra <code class="highlighter-rouge">plugin p2</code> to our <code class="highlighter-rouge">program P</code>. <code class="highlighter-rouge">p2</code> depends on both <code class="highlighter-rouge">f1</code> and <code class="highlighter-rouge">f2</code>. Parallelly, the developers of <code class="highlighter-rouge">library L</code> have iterated through their own cycle of development. In the latest iteration, they improved implementation of <code class="highlighter-rouge">f1</code> keeping the interface to <code class="highlighter-rouge">f1</code> unaltered. However, they realized that <code class="highlighter-rouge">f2</code> needs a reformation of the interface also. Additionally they developed a new <code class="highlighter-rouge">functionality f3</code> and released these improvements in their latest <code class="highlighter-rouge">version ( y + 1 )</code>. Let us denote this version by <code class="highlighter-rouge">L( y + 1 )</code>.</p>

<p>Now there are two impending questions here. The first question is how does the <code class="highlighter-rouge">library L</code> developer community communicates to their users of their new changes. The second question is how does the <code class="highlighter-rouge">program P</code> community go about adopting the latest version <code class="highlighter-rouge">L( y + 1 )</code>.</p>

<p>One way to address the first question is  through extensive documentation of the new version so that that application developers can go through the documentation and take note of the changes and accordingly take the decision of migrating to the newer version of the <code class="highlighter-rouge">dependency L</code>.</p>

<blockquote>
  <p>However developers are poor documenters.</p>
</blockquote>

<p>Instead, a set of rules evolved with the community to convey quickly what might have possibly changed in the new version. This collection of rules for versioning software is called <strong>semantic versioning</strong>.</p>

<p>The second question is what leads to the possibility of <strong>software dependency hell</strong>.</p>

<hr />

<h2 id="semantic-versioning">Semantic Versioning</h2>

<p><a href="https://semver.org/">Semantic versioning</a> is a way to avoid what is commonly called the <strong>software dependency hell</strong>. Software dependency hell swings the choice of upgrading software between two limiting scenarios.</p>

<h3 id="dependency-hell-spectrum--version-locking-vs-version-promiscuity">Dependency hell spectrum : Version locking vs version promiscuity</h3>
<p>At the one end of what is called as <strong>version locking</strong>, the developer community of program P makes a choice to upgrade P without depending on the latest version of <code class="highlighter-rouge">L</code> as the interface of <code class="highlighter-rouge">functionality f2</code> has changed and would break the implementation of <code class="highlighter-rouge">plugin p2</code>. By version locking of the <code class="highlighter-rouge">dependency L</code>, we loose out on the performance improvements of <code class="highlighter-rouge">plugin p1</code> as the latest version of L has improved version of <code class="highlighter-rouge">functionality f1</code> on which <code class="highlighter-rouge">plugin p1</code> depends. It does not mean the <code class="highlighter-rouge">program P</code> cannot be upgraded. The latest version <code class="highlighter-rouge">p( x + 1)</code> can contain <code class="highlighter-rouge">plugin p2</code> with dependency <code class="highlighter-rouge">L(y)</code>.</p>

<p>At the other end of the spectrum of dependency hell, the developer community decides to upgrade P by depending on the latest version <code class="highlighter-rouge">L( y + 1 )</code> to gain the performance improvement of <code class="highlighter-rouge">plugin p1</code> (as there is improvement of <code class="highlighter-rouge">functionality f1</code> on which <code class="highlighter-rouge">p1</code> depends) even at the cost of <strong>breaking</strong> <code class="highlighter-rouge">plugin p2</code>. Additionally there is a possiblity of developing a new <code class="highlighter-rouge">plugin p3</code> that might use <code class="highlighter-rouge">functionality f3</code>. The possibility of breaking code might seriously affect the end user of the program and this sort of upgradation of software comes under what is called as <strong>version promiscuity</strong>.</p>

<p>Either ends of the spectrum are harmful to software development. To choose a middle path, semantic versioning helps one take an informed judgement on if and when to upgrade software.</p>

<h3 id="semantic-versioning-specification">Semantic versioning specification</h3>

<p>The developer community over the course of years have come up with a set of rules on how to version their individual softwares so that software interdependency can be resolved in a sane way. A typical iteration of software development involves three steps</p>

<ul>
  <li>feature enhancement</li>
  <li>feature testing</li>
  <li>feature release or shipping</li>
</ul>

<h4 id="feature-enhancement">Feature enhancement</h4>

<p>The semantic versioning rules are closely associated with these steps. A feature enhancement can be of type <strong>MAJOR</strong> like a rework on the Application Programmer’s Interface(API). This needs to send alarm bells to the users of this API as their programs will not be compatible with this new API. As a result this enhancement is called being <strong>backwards incompatible</strong>. A feature enhancement can be of type <strong>MINOR</strong> like adding new functionality without breaking existing API. This enhancement is called being <strong>backwards compatible</strong>. This feature may improve implementation of existing functionality or be a complete new functionality in which case it <strong>adds to the API</strong> and at the same is being backwards compatible. A third type of feature enhancement is fixing bugs. A bug is a wrong implementation of a feature leading to erroneous behaviour of the program using the API. An enhancement  that fixes bugs is called a <strong>PATCH</strong>. A patch neither improves existing functionality nor adds new functionality. It only corrects/fixes existing functionality.</p>

<p>The above is for a particular iteration of the development of the program. To capture the entire timeline of the development, the type of feature enhancements ever done are coded in the <strong>version</strong> of software with a format <code class="highlighter-rouge">MAJOR.MINOR.PATCH</code> of dot separated numerical identifiers for <code class="highlighter-rouge">MAJOR</code>, <code class="highlighter-rouge">MINOR</code> and <code class="highlighter-rouge">PATCH</code>. Each of these numerical identifiers are whole numbers.</p>

<blockquote>
  <p>With every iteration of the development, depending on the type of feature enhancement carried out, the corresponding identifier is incremented by 1 and is called a <strong>release</strong>.</p>
</blockquote>

<p>For example, let the current version of <code class="highlighter-rouge">program P</code> is <code class="highlighter-rouge">v1.0.0</code> and current version of <code class="highlighter-rouge">library L</code> is <code class="highlighter-rouge">v1.1.2</code>. This means till now there has been one API release for L and followed by 1 minor release of backwards compatible enhancements in the functionalities followed by 2 releases of bug fixes. Similarly program P has only a major release after which there is no further development. However nothing is known of previous major releases and its sub releases of minors and patches.</p>

<p>It should be noted that once a version is released, there is no going back. At the most, one can do a bug fix for the release in future.</p>

<h4 id="feature-testing">Feature testing</h4>

<p>The above releases are called <strong>normal releases</strong> or <strong>stable releases</strong>. Since version releases are only forward directional, developers of large projects <strong>pre-release</strong> a software prior to the actual release. The reason is two fold;to let the common user know that they are <strong>unstable</strong> and therefore stay away from it as they can potentially break the global system like the Operating system and what not. These release are intended for power users in the hope that they fish out remaining bugs. Pre-release is distinguished from a normal release by suffixing terms like <strong>alpha</strong>, <strong>beta</strong>, <strong>rc</strong> with a hyphen.</p>

<ul>
  <li>Alpha pre-release may not contain all the features planned for the final release, but at the end of the alpha phase, the software is feature complete. Proprietary software do not release their alpha-pre releases to the general public unlike open source software.</li>
  <li>Beta pre-relase phase starts with feature complete software but has bugs. This is pre-released in the open source community for bug testing.</li>
  <li>Release candidate (rc) pre-release has the potential to be <strong>stable</strong>.</li>
</ul>

<p>For more info, check this <a href="https://en.wikipedia.org/wiki/Software_release_life_cycle#Pre-alpha">Wikipedia article on Software release life cycle</a>.</p>

<h3 id="feature-release">Feature release</h3>

<p>Once there is reasonable certainty that the pre-releases are stable, they are released with versioning following the rules of semantic versioning.</p>

<h3 id="precedence-of-versions">Precedence of versions</h3>

<p>When comparing releases with respect to the time ordering of the releases, the precedence is calculated by comparing separately the major, minor, and path and pre-release identifiers.</p>
<ul>
  <li>1.x.y &lt; 2.p.q for any x, y, p, q</li>
  <li>1.0.y &lt; 1.1.q for any y, q</li>
  <li>1.0.0-<pre-release> &lt; 1.0.0</pre-release></li>
  <li>1.0.0-alpha &lt; 1.0.0-beta &lt; 1.0.0-rc</li>
</ul>

<h2 id="a-concrete-example-of-inkscape-development">A concrete example of Inkscape development</h2>

<p>Inkscape is a mature project with a history of more than 16 years. The current release as of 29th of May, 2020 is 1.0.0. Prior versions were of the type 0.x.y</p>

<p>The major version increment means there is some backwards incompatible. From the <a href="https://wiki.inkscape.org/wiki/index.php?title=Release_notes/1.0#python3">Inkscape v1.0.0 release documentation</a>, it is clear that Inkscape has migrated to using GTK+3. Earlier v0.x.y versions were using GTK+2. GTK (Gimp Tool Kit) is a widget based took kit for creating graphical user interfaces. However the major version increment is not due to shifting to GTK+3, but it is due to backwards incompatible SVG?? (I dont know what that means) I think it means that SVG standard has upgraded itself. To incorporate the newer SVG standard, Inkscapes API has been modified (remember that Inkscape provides a command line mode.. so in effect inkscape can be used as an API as in for Inkscape extensions!!!)</p>

<hr />



  



  </body>
</html>
